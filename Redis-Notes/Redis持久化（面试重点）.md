# Redis持久化==（面试重点）==

- Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失，所以需要持久化

- RDB是保存状态，AOF保存的是写操作（日志），通过重演日志可以得到状态



### RDB（Redis DataBase）

![image](https://user-images.githubusercontent.com/106053649/181217966-9fd91c1d-e9fa-4f37-b51e-4733a2272539.png)

- 在指定的时间间隔内将内存中的数据集快照写入磁盘，就是行话将的Snapshot快照，恢复时将快照文件直接读到内存里
- Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。
- 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
- RDB的缺点是最后一次持久化后的数据可能丢失。Redis默认就是RDB，一般情况下不需要修改这个配置
- RDB保存的是dump.rdb文件，有时候实际生产环境中会对dump.rdb进行备份



#### 触发机制

- save规则满足的情况下，会自动触发rdb规则

```bash
save 60 5	#表示60s内执行了5条命令就触发RDB机制进行快照，产生dump.rdb文件
```

- 执行flushall命令，也会触发rdb规则
- 退出redis，也会产生rdb文件



#### 恢复机制

- 只需要将rdb文件放在redis启动目录下即可，redis启动时会自动检查dump.rdb文件并恢复其中的数据



#### RDB优缺点

- 优点：
  - 适合大规模的数据恢复
  - 对数据的完整性要求不高（比如59s执行了4秒正好服务器宕机了，这4条命令修改的数据就没了）

- 缺点：
  - 需要一定的时间间隔操作！上述意外宕机会导致一些修改的数据没了
  -   fork进程的时候，会占用一定的内存空间



### AOF（Append Only File）

![image](https://user-images.githubusercontent.com/106053649/181218011-b9404ca8-3eb1-4589-bf6e-cb3e1a946008.png)

- 将所有的写操作命令（不记录读操作）都记录下来，恢复的时候重新执行命令

- 以日记的形式来记录每个写操作（读操作不记录），只许追加文件但不可以修改文件。Redis启动之初会读取该文件并重新执行命令构建数据

- AOF保存的是appendonly.aof文件，该机制默认不开启，需要手动进行配置



#### 手动改错aof文件

- 首先更改配置打开AOF机制，对于redis操作后生成了aof文件
- 关闭redis客户端和服务器后通过vim将aof文件里的命令改错了
- 再次打开redis服务器，连接客户端时拒绝访问
  - 此时通过redis-check-aof修复aof文件后才可以重新访问（可能会丢失一些数据）
  - 虽然也有redis-check-rdb，但不能类似aof这样操作（rdb记录的不是写操作命令，打开也看不懂）

```bash
redis-check-aof -- fix appendonly.aof
```



#### AOF优缺点

- 优点：
  - 每一次修改都同步，文件的完整性会更好
  - 默认是每秒同步一次，可能会丢失一秒的数据
  - 从不同步，效率是最高的
- 缺点：
  - 对于数据文件来说aof远远大于rdb，修复的速度也比rdb慢
  - aof运行的效率也比rdb慢（==持续IO==），所以redis默认的配置就是rdb持久化而不是aof



#### 重写规则说明

- 如果aof文件大于64mb，太大了！fork一个新的进程来将文件进行重写



### 扩展

- 如果Redis只是用来做缓存，没有必要持久化
- 同时开启两种持久化方式时，Redis重启会优先载入AOF文件来恢复原始数据（通常AOF文件保存的数据比RDB文件更完整）
- RDB一般用作从机的持久化，一般15分钟备份一次就够了，保留save 900 1这条规则
- 开启AOF最恶劣也不会丢失超过两秒的数据，代价是持续的IO以及超过64mb重写文件时产生的不可避免的阻塞（将64mb改大）
- 不开启AOF利用主从复制实现高可用性也可以，能省掉很多IO，也减少了AOF重写时的系统波动。
  - 代价是主/从同时宕机会丢失十几分钟的数据
  - 恢复时比较两个主/从中的RDB文件，载入比较新的那个（比较大的文件）
