# HTTP

### 1、HTTP常见状态码

- 状态码为3位整数，1开头代表信息通知；2开头代表操作成功；3开头代表重定向，需要进一步操作；4开头代表客户端错误，无法完成请求；5开头是服务器错误

##### ==1开头的状态码==

- 表示continue，**post**请求先发header，服务器返回100表示continue，之后才发data，请求成功后返回200

##### 2开头的状态码

- **200**：请求成功，一般是GET和POST请求。
- **201**：创建了一个新资源，发送此响应代码，一般是POST/PUT/PATCH请求。
- **204**：是指服务端接受了客户端的请求，但是通知客户端资源不能改变。

##### ==3开头的状态码==

- **==301==**：永久重定向，**302**表示临时重定向，若发生重定向，响应头中会多出一个==Loaction字段==，标记了要重定向的**URL**

- **303** 重定向，使得客户端可以请求，但是不强迫客户端下载其所有数据。可以向响应报头中的URL发送GET请求获取资源。
- **304**：主体为空，主要是由于服务端信息相较于缓存来说没有改变，返回304。
- **307**：指资源不在本地，对于GET来说，是让客户端重新定向到镜像站点发起Get请求。而对于PUT\POST\DELETE\PATCH来说，是要向重定向的URL提交整个新的请求。

##### 4开头的状态码

- **400**：通用的错误状态码
- **401**：客户端对一个受保护的资源进行操作，但是没有正确的证书提供。
- **403**：当某个资源只允许特定时间段或者特定IP地址的用户访问的话，拒绝访问就是403。
- **404**：无法把请求的URI转换为一个资源，404有时候也是用来掩盖401或403的，不想通过401\403透露信息。
- **415**：指代请求的实体信息无法识别，请求失效。

##### 5开头的状态码

- **500**：通用的错误响应，执行请求发生异常
- **503**：HTTP服务器正常，下层WEB服务不能正常工作，常见于资源不足，服务器突然收到大量请求



### 2、HTTP常见请求

![image-20220728214706760](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220728214706760.png)



### 3、GET和POST

- 一般来说GET是获取数据，POST是提交数据的。

- 但是因为GET和POST都是HTTP的方法，HTTP又是是基于TCP/IP的关于数据在万维网中如何让通讯的协议。

- 所以本质上来说GET和POST请求是没有区别 的，都是TCP链接。他们能做的事情是一样的。

- 就比如bool的true和false以及int的0和1，都能拿来做条件判断，但习惯还是用bool类型来表示逻辑是非。

- HTTP协议既然有了这两个方法，就是为了在特定的情况下区分应用。就有了我们所说的GET是获取数据，POST是提交数据的。



#### get和post的区别

##### 1、数据发送机制

- 对于GET方式的请求，浏览器会把http header和data一**并发送**出去，服务器响应状态码200 ok 请求成功（返回数据）。
- 对于POST，**浏览器先发送header**，服务器响应状态码100 continue，**浏览器再发送data**，服务器响应200 ok 请求成功（返回数据）。

##### 2、数据传输方式

- GET传输数据的时候是在URL地址中的、对所有人都是是可见的、是不安全的、是有[浏览器缓存](https://so.csdn.net/so/search?q=浏览器缓存&spm=1001.2101.3001.7020)记录的。所以说GET是不安全的，发送密码等数据的时候不要用GET传输。
- POST传输的时候是放在HTTP的请求体之中的，并且是经过urlencode编码的所以是相对安全的。
- GET只能传输ASCII字符，不能进行编码。POST是没有对数据类型的限制的，二进制数据也是可以的。

##### 3、请求长度限制

- HTTP协议并没有对GET和POST的长度做限制，其实是浏览器限制了他们传输大小。
- URL地址是有长度限制的，浏览器不同长度限制的具体数值也是不一样的。需要注意的是这些仅仅是URL地址栏的长度限制。

- 理论上来说POST的长度是没有限制的，但是受服务器的配置限制或者内存大小的限制，造成了实际开发中POST也是有数据长度的限制的。

##### 4、速度

- POST需要在请求的body部分包含数据，所以会多了几个描述部分的首部字段比如：content-type，但这是微乎其微的，可以忽略不计。

- 根据数据发送机制，POST是要比GET多进行一次数据传输的，所以GET请求就比POST请求更快。（现代网速，影响不大了）

##### 5、请求的幂等性

- GET是获取数据，所以GET请求是安全且幂等的，是无害的。这个安全指得是对数据不会造成影响。
  - 幂等简单的来说就是无论获取多少次数据得到的资源都是一样的。

- POST是向服务器传输数据，数据会被重新提交，所以就会有对原有的数据造成伤害。



总结：

- GET产生一个TCP数据包；POST产生两个TCP数据包。
- 最直观的区别就是GET把参数包含在URL中；POST通过请求体传递参数（POST进行处理请求提交的数据 被包含在请求体中）。
- GET在url中传参，网络中能看到，不安全；POST在数据包中传参，相对安全。



### 4、CSRF和XSS攻击

#### 1、CSRF攻击

- 跨站点请求伪造(Cross—Site Request Forgery)，即你的身份被盗用，以你的名义发起恶意请求。
- 对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作

CSRF攻击原理及过程如下：

>1、用户打开浏览器，访问受信任的网站A，输入用户名和密码登陆网站A
>
>2、用户身份信息验证后，网站A产生cookie信息并返回给浏览器，此时登陆成功可以给网站A发起请求
>
>3、用户未退出网页A时，在同一浏览器中打开了新页面访问危险网站B
>
>4、网站B收到用户请求后，返回一些攻击性的代码，并发出请求要访问第三方站点A
>
>5、浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
>
>6、由于网站A不知道该请求其实是由B发起的，会根据之前验证的用户及cookie信息处理请求，导致B网站的恶意代码被执行



#### 2、CSRF防御

**跨站攻击的本质是， 攻击者拿着你的“身份凭证”，冒充你进行的相关攻击行为**。

- 因为“身份凭证”是Cookie中存储的，所以防护机制的处理对像也是Cookie的数据。
- 我们要在防护的数据中加入签名校验，并对数据进行生命周期时间管理，就是数据过期管理。（判断签名和时间戳）



#### 3、XSS攻击

- 跨站脚本攻击，通常是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页。



#### 4、XSS防御

- 采用拦截器或过滤器对输入的信息做过滤处理



### 5、输入URL到页面显示的全过程

- 根据域名进行DNS解析（为了得到IP地址）
  - 首先在浏览器缓存中查找，没有的话在本地缓存查找，依旧没有向DNS服务器递归或者迭代查询==（UDP协议）==
- 拿到IP地址和端口号就可以访问服务器了，首先尝试HTTP通过socket相关API建立TCP连接
- 三次握手成功建立连接后，传送数据，如果不是HTTP协议，服务器返回5开头的重定向消息，告诉用的是HTTPS
- 四次挥手断开连接，再次三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。
- 确认无误后，开始通信，服务器处理客户端发起的请求
- 返回请求结果，视keep-alive字段是否是长连接，选择是否关闭TCP连接
- 浏览器解析HTML请求，并进行布局渲染，得到最后的页面



### 6、cookie和session

#### 1、cookie

HTTP 协议是无状态的，HTTP/1.1 引 入 Cookie 来保存状态信息。

- Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据
- 它会在浏览器之后向同一服务器再次发 起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。
- 换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。
- cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够通过cookie认出你。



#### 2、session

- 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

- Session可以存储在服务器上的文件、数据库或者内存中。也可以将Session 存储在Redis这种内存型数 据库中，效率会更高。



使用 Session 维护用户登录状态的过程如下：

- 用户登录时，用户提交用户名和密码信息，放入HTTP请求报文中
- 服务器验证该用户名和密码，如果正确的话将用户信息存到Redis中，其中Key为SessionID
- 服务器返回的响应报文的Set-Cookie首部字段包含了SessionID，客户端收到响应报文后将该Cookie值存入浏览器中
- 客户端之后对同一服务器进行请求时会包含该Cookie值，服务器收到后提取出SessionID，从Redis中取出用户信息，继续之前的业务操作



### 7、HTTP请求格式

请求数据分为3部分：

- 请求首行：请求方法 + URL + 版本号。
- 请求头（header）：格式为key：value形式。
  - 有一个空行区分请求头和请求体。
  - body可有可无，若body存在，则在header中会定义一个content-length属性来标识body的长度。
- 请求体（body）：Post请求的最后一部分，存放请求参数。



#### 1、请求首行

首行 = 方法 + URL + 版本号

- 其中一个完整的URL包括==协议://主机名(域名):端口号/资源路径/查询字符串query string==

>https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor
>
>- `https://` 协议名
>- `www.example.` 域名，等价于IP地址，能够表示一个网络上的主机
>- `com:80` 端口号为80，一般情况下端口号都会省略。80为HTTP，443为HTTPS
>- 资源路径：/path/to/myfile.html 带层次的文件路径，用于定位到程序管理的资源
>- query string：其本质是一个键值对结构，用于在请求中带上一些参数信息，传递给服务器，即请求的资源
>  - GET的请求体body为空，故用query string传输数据
>  - POST的请求体boby不为空，其query string一般为空，请求参数在body中



#### 2、请求头

常见的key：value对有：

- Host：请求的主机名
- Connection：是否保持连接（close或keep alive）
- Cookie
- 客户端接受的语言、编码方式等
- 若是Post请求，则必定请求体不为空，会有额外两个字段：
  - Content-Length表示body的长度，单位是字节。GET中一般没有body,所以抓包POST请求才能看到该header。
  - Content-Type表示body的格式，表单、图片、json等



#### 3、请求体



### 8、VPN和NAT

#### 1、虚拟专用网VPN

- 利用共用的因特网作为本机构各专用网之间的通信载体（VPN保证安全，需要对数据加密）
- 公司员工运行PC上的VPN软件，在员工的PC和公司的主机之间建立VPN隧道
- 部门A专用网对应至少一个有全球IP地址的路由器，部门B同理，加密后通过路由器的IP地址通过因特网与另一个部门的路由器的IP地址进行通信

#### 2、网络地址转换NAT

- 主要用于解决IPV4地址的紧缺，虚拟专用网可以使用任意IP地址，通过用全球IP地址的路由器转发
- 比如虚拟专用网有很多主机使用不同的IP地址，再与外部因特网的全球IP地址通信时，会经过具有NAT功能的路由器，将IP数据包中的源地址（专用网地址）改为路由器中的全球IP地址，并记录该映射关系
- 转换为全球IP地址后发给目的地址的全球IP地址，若回发数据，则通过全球IP地址找到路由器，根据映射关系找到对应的专用IP地址

>缺点：
>
>- NAT路由器中有几个全球IP地址，则专用网中只能同时最多有这么多主机与因特网通信
>- 改用NAPT协议，将IP地址与端口号一起进行转换，即IP:PORT的形式



### 9、HTTP1.0、1.1、2.0

#### 1、HTTP1.0和2.0的区别

##### 1）长连接

- HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应

##### 2）节约带宽

- HTTP1.1支持只发送header信息（不带任何body信息）
  - 如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器
  - 如果返回401，客户端就可以不用发送请求body了节约了带宽。



#### 2、HTTP1.1和2.0的区别

##### 1）多路复用

- 使用了==多路复用==的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
- HTTP1.1也可以通过==多建立几个TCP连接==，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。

##### 2）头部数据压缩

-  HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩

##### 3）服务器推送

- 服务端推送是一种在客户端请求之前发送数据的机制，允许服务端推送资源给浏览器。



### 10、IP协议

IP只为主机提供一种**无连接、不可靠的、尽力而为**的数据包传输服务。主要包括三方面内容：IP编址方案、分组封装格式以及分组转发规则

#### 1、IP编址方案

IP地址=网络号+主机号

##### 1）分类编码

- 分为ABCDE五类地址，主要是ABC三类，A类（8bit0开头），B类（10开头），C类（110开头）

##### 2）划分子网

- 主机号被借用几个bit用作子网号（子网掩码）

##### 3）无分类编码

- IP地址后加/数字表示前多少个是网络号，如128.14.35.7/20表示前20为网络号，后12为主机号

#### 2、IP数据报封装格式

IP数据包为首部+数据载荷，其首部格式如下：

![image-20220823130625264](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220823130625264.png)



#### 3、IP数据报的分组转发规则

- 当IP数据包经由路由器转发时，如果目标网络与本地路由器直接相连，则直接将数据包交付给目标主机，这称为直接交付；
- 否则，路由器通过路由表查找路由信息，并将数据包转交给指明的下一跳路由器，这称为间接交付。



### 11、TCP和UDP

#### 1、TCP报文首部格式

![image-20220823131610638](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220823131610638.png)

![image-20220823131718482](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220823131718482.png)



#### 2、UDP首部格式

![image-20220823131822996](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220823131822996.png)



### 12、路由环路

在有默认路由的情况下，以下可能出现路由环路[4.5 静态路由配置及其可能产生的路由环路问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1c4411d7jb?p=49&vd_source=8de202879dcd70a5bed8b07da0ce64f0)：

1、聚合了不存在的网络

2、网络故障

> 可以通过增加黑洞路由来解决



1、OSPF为开放最短距离优先，克服RIP缺点（基于Dijkstra算法）

2、RIP存在“坏消息传得慢”，即路由环路问题

![image-20220823133910315](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220823133910315.png)

>- RIP会持续和周围直连路由交换路由表
>
>- 若R1检测N1故障不可达，将其跳数设置为16，并在下次与R2交换该信息
>- 若R2更新时间先到，将自己路由表中到N1的距离发给R1（是原来到R1的基础上加1的跳数）
>- 由于最短跳数优先，R1将其到N1的距离修改为其到R2的跳数加1
>- 互相误导，知道双方的路由表中都到16时才解决，中间形成了很长时间的路由环路



### 13、浏览器多进程

- 浏览器是多线程的，浏览器为每个标签页开启了独立的渲染进程，每个进程之间的资源（CPU，内存等）和行为（UI，逻辑等）互不共享，所以即使某个标签页奔溃了也不会影响其他标签页。
- 而在每个标签页中，浏览器会把不同的工作交给对应的线程，比如GUI线程负责把HTML渲染成可视化的UI，JavaScript引擎线程负责解析和运行JavaScript代码逻辑，定时触发器线程负责处理setTimeout/setInterval定时器。

