# Unix网络编程——进程相关

### 虚拟地址空间

![image-20220710153700265](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220710153700265.png)

- 虚拟地址空间分为用户区（0-3G），内核区（3G-4G）
- 会被CPU映射到真实物理内存
- 实际不存在，可执行程序执行时sys为其创建虚拟地址空间

- #### 用户区

- 收保护的地址（0-4K）：NULL，nullptr

- 堆从内存低地址往高地址存，栈从内存高地址往低地址存

- #### 内核区

- 内核区数据没法操作，但可以通过系统调用（Linux系统API）进行操作



### 文件描述符

![image-20220710154417648](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220710154417648.png)

- PCB进程控制表里有一个数组（文件描述符表），大小默认为1024
  - 每个进程默认最多能打开1024个文件



### 进程的状态

![image-20220710154901791](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220710154901791.png)



### 创建进程fork

- fork函数会分别在父进程和子进程中返回
  - 父进程中返回子进程的进程号（若创建失败返回-1）
  - 子进程中返回0

- #### 父子进程的关系

- 区别：

  - fork的返回值不同
  - pcb中的一些数据
    - 当前进程的id（pid）
    - 当前进程的父进程的id
    - 信号集

- 共同点（刚创建出来未执行写操作）
  - 用户区的数据
  - 文件描述符表

- 父子进程对于变量读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。



### 孤儿、僵尸进程

- #### 孤儿进程

- 父进程运行结束，子进程还在运行（父进程无法执行回收子进程PCB资源的义务）

- 内核会把孤儿进程的父进程设置为init（Linux内核的第一个进程），会循环调wait()回收资源

- 孤儿进程无危害

- #### 僵尸进程

- 一个进程终止，但其父进程没有调用wait()/waitpid()回收资源，成为僵尸进程

- 僵尸进程不能被kill -9杀死

- 通过杀死父进程，僵尸进程变成孤儿进程（由进程号为1的init进程托管）

- #### wait和waitpid

- 调用wait()的进程会阻塞，直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒

- waitpid回收指定进程号的子进程，可以设置是否阻塞



### 进程间通信（IPC）

- 管道两端对应两个文件描述符，可进行读、写操作（但不存储数据）

- #### 一、匿名管道

- 无文件实体，一般用于父子进程间或者子进程和子进程之间通信（fork后共享文件描述符）

- #### 二、有名管道

- 具有文件实体，通过mkfifo创建得到文件描述符，当普通文件操作（任意进程可以打开）

- #### 三、信号（内核处理，软中断）

- 如终端（一个进程）运行一个可执行文件（第二个进程），终端输入crtl+c（信号杀死可执行程序）
- 再如一个程序，alarm定时器到期引起SIGALRM信号，结束当前进程

- 通过signal和sigaction设置某个信号的捕捉行为（回调）
  - 实际回调也没啥用，回调函数的参数是一个int型的信号，能做的事太有限了
  - 一般用于捕捉子进程的SIGCHLD信号并调waitpid回收资源（while死循环直到没有子进程）
    - 这种信号触发方式可以防止父进程挂起回收子进程，可以执行自己的业务逻辑
    - 用waitpid比较好，非阻塞，用wait的话回调函数会阻塞
    - 必须while死循环回收，虽然每个子进程退出都会产生SIGCHLD信号
    - 但未决信号集的每个标志位只有0和1表示，只能知道有但不知道有几个
    - 比如一个子进程死亡产生SIGCHLD，未决信号集该位置为1，去处理该信号
    - 同时又产生了许多SIGCHLD信号，此时还是1，这些相当于没作用被舍弃了
  - 检测到信号，回调进入内核态处理（软中断），处理完回到原本中断的位置

![image-20220710171530372](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220710171530372.png)

- 简单来说：
  - main函数中通过进入内核态（通过系统调用或者中断、异常等）
  - 处理完异常回用户态之前会处理当前进程中可以递送的信号
  - 如果信号的处理动作为自定义信号处理函数
    - 回到用户态处理信号处理函数（不回到主控制流程的中断处）
    - 处理完后回到内核态
  - 返回用户态的中断处继续往下执行
  
- 信号集（下一段再讲）

- #### 四、消息队列

- 消息队列其实就是消息缓冲区，如事件驱动的生产者消费者模型

  - 生产者产生了Message并将其加入消息缓冲区（消息队列）
  - 消费者在loop中不断去获取Message并处理

- MIT6.824实验中我自己实现的Raft层同KvServer层的通信其实就是消息队列

- #### 五、信号量

- 信号量可用于线程间的同步和进程间的同步（设置某个参数）

- 也是一种进程间通信的方式（同时感知变量的状态）

- #### 六、mmap系统调用（操作内存，效率高）

- ```c++
  void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
  void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  munmap(ptr, size);		//需要释放
  ```

- mmap可以把一个文件（磁盘中）映射到进程内存中，之后操作这块内存相当于操作文件

- 文件存在与文件系统中，不同进程都能通过文件描述符操作它，所以mmap也算一种IPC方式

![image-20220710174102112](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220710174102112.png)

- 会映射到虚拟地址空间的共享库区域中，可选择文件一部分映射
- 两个进程都通过mmap映射到该文件对应部分，进行操作都可见

- #### 七、共享内存

- 允许两个或多个进程共享物理内存的同一块区域，该区域会成为一个进程用户空间的一部分（该IPC无需内核介入，快）

- 关键的API如下，以及将共享内存和当前进程关联

- ```c++
  //创建共享内存段或取得一个既有的共享内存段（其他进程创建的），返回值是一个int型的共享内存标识符
  int shmget(key_t key, size_t size, int shmflg);		//key：通过这个找到或者创建一个共享内存
  //将共享内存段和当前的进程进行关联
  void *shmat(int shmid, const void *shmaddr, int shmflg);
  ```

- 具体简单例子如下：

- ```c++
  //read.cpp
  #include <stdio.h>
  #include <sys/ipc.h>
  #include <sys/shm.h>
  #include <string.h>
  
  int main() {    
  
      // 1.获取一个共享内存
      int shmid = shmget(100, 0, IPC_CREAT);
      printf("shmid : %d\n", shmid);
  
      // 2.和当前进程进行关联
      void * ptr = shmat(shmid, NULL, 0);
  
      // 3.读数据
      printf("%s\n", (char *)ptr);
      
      printf("按任意键继续\n");
      getchar();
  
      // 4.解除关联
      shmdt(ptr);
  
      // 5.删除共享内存
      shmctl(shmid, IPC_RMID, NULL);
  
      return 0;
  }
  
  //write.cpp
  #include <stdio.h>
  #include <sys/ipc.h>
  #include <sys/shm.h>
  #include <string.h>
  
  int main() {    
  
      // 1.创建一个共享内存
      int shmid = shmget(100, 4096, IPC_CREAT|0664);
      printf("shmid : %d\n", shmid);
      
      // 2.和当前进程进行关联
      void * ptr = shmat(shmid, NULL, 0);
  
      char * str = "helloworld";
  
      // 3.写数据
      memcpy(ptr, str, strlen(str) + 1);
  
      printf("按任意键继续\n");
      getchar();
  
      // 4.解除关联
      shmdt(ptr);
  
      // 5.删除共享内存
      shmctl(shmid, IPC_RMID, NULL);
  
      return 0;
  }
  ```

- 共享内存和内存映射的区别
  - 共享内存效率更高
  - 所有进程操作同一块共享内存
  - 每个进程在自己的虚拟地址空间中有自己独立的内存（通过文件关联）

- #### 八、SOCKET

- 不同主机间进程通信较多（网络通信），也可本地不同进程间通信



### 信号集

- 可能许多系统调用需要处理一组不同的信号，则用一个数据类型为sigset_t的数据结构存多个信号
- PCB中两个重要的信号集（位图机制实现）
  - 未决信号集：信号产生到被处理前的状态称为未决，被处理前的信号都在其中
  - 阻塞信号集：阻止该集合中的信号被处理
- 不允许直接对这两个信号集进行位操作
  - 自定义一个集合，借助信号集操作函数对PCB中这两个信号集进行修改（类似select）

- 示例流程
  - 按下ctrl+c产生了一个2号信号SIGINT（信号被创建）
  - 此时该信号未被处理，存在未决信号集中，第二个标志位置为1
  - 该未决状态的信号需要被处理，但在处理之前需要与阻塞信号集进行比较
  - 若阻塞信号集2号标志位为0，则允许被处理，若为1则该信号继续处于未决，直到阻塞解除
- 阻塞信号集默认不阻塞任何信号，可通过系统API进行更改
  - sigprocmask()将自定义信号集的数据设置到内核中（内核本身阻塞的不管，把自己阻塞的放进去）



### 中断

- 计算机运行过程中，当发生某个事件后，CPU 会停止当前程序流，转而去处理该事件，并在处理完毕后继续执行原程序流。
- 引入中断好处：**化主动为被动，避免 CPU 轮询等待某条件成立**
  
- 使用中断机制，就可以在条件成立之后，向 CPU 发送中断事件，强制中断 CPU 执行程序，转而去执行中断处理程序。
  
- #### 硬中断

- 硬中断由外部设备（例如：磁盘，网卡，键盘，时钟）产生，用来通知操作系统外设状态变化

  - 时钟中断就是一种硬中断，用于定期打断 CPU 执行的线程，以便切换给其他线程以得到执行机会。

- 硬中断的处理流程如下：

  - 外设将中断请求发给中断控制器
  - 中断控制器根据中断优先级，有序将中断传递给CPU
  - CPU终止执行当前程序流，将CPU所有寄存器的数值保存到栈中
  - CPU根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序
  - CPU恢复寄存器中的数值，返回原程序流停止位置继续执行

- #### 软中断

- 软中断是一条 CPU 指令，由当前正在运行的进程产生（系统调用）

- 软中断模拟了硬中断的处理过程：

  - 无
  - 无
  - CPU终止执行当前程序流，将CPU所有寄存器的数值保存到栈中
  - CPU根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序
  - CPU恢复寄存器中的数值，返回原程序流停止位置继续执行

- 系统调用：是一种软中断处理程序，让程序从用户态进入内核态，以执行相应操作

  - 用户无法直接访问内核区数据，必须通过系统调用