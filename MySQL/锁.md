# 锁

# 概述

MySQL中的锁，按照锁的粒度分，分为以下三类：

- 全局锁：锁定数据库中的所有表。

- 表级锁：每次操作锁住整张表。

- 行级锁：每次操作锁住对应的行数据。



# 全局锁

## 基本概念

- 全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

- 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。



## 语法

- 加全局锁

```sql
flush tables with read lock ;
```

- 数据备份

```sql
mysqldump -uroot –p1234 itcast > itcast.sql
```

- 释放锁

```sql
unlock tables ;
```

>加了全局锁之后，只能查不能写



## 特点

数据库中加全局锁，是一个比较重的操作，存在以下问题：

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。

- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。

>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。

```sql
mysqldump --single-transaction -uroot –p123456 itcast > itcast.sql
```





# 表级锁

对于表级锁，主要分为以下三类：

- 表锁

- 元数据锁（meta data lock，MDL）

- 意向锁

## 表锁

对于表锁，分为两类：

- 表共享读锁（read lock）

- 表独占写锁（write lock）

语法：

- 加锁：lock tables 表名... read/write。

- 释放锁：unlock tables / 客户端断开连接 。

### 读锁

特点：

- 一个客户端加了读锁，当前客户端能读不能写
- 其他客户端能读，也不能写

### 写锁

特点：

- 一个客户端加了写锁，当前客户端既能读，也能写
- 但是其他客户端既不能读，也不能写



## 元数据锁

meta data lock , 元数据锁，简写MDL。

MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。

MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。

为了避免**DML**与**DDL**冲突，保证读写的正确性

>这里的元数据，可以简单理解为就是一张表的表结构。
>
> 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。





## 意向锁

### 介绍

> 在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁

- 无意向锁时，一个线程A对表执行更新操作，会对更新行加行锁
- 此时线程B如果对这张表加表锁，需要从第一行一直向下检查看是否有加锁
- 引入意向锁后，线程A对表执行更新操作，对更新行加行锁后再对整张表加一个意向锁
- 线程B对这张表加表锁时，会根据该表上所加的意向锁来判定是否可以成功加表锁，无需逐行检查



### 分类

- 意向共享锁(IS): 由语句select ... lock in share mode添加 。 
  - 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。

- 意向排他锁(IX): 由insert、update、delete、select...for update添加 。
  - 与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。





# 行级锁

## 基本概念

>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁

对于行级锁，主要分为以下三类：

- 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持
- 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持

- 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据**前面**的间隙Gap。在RR隔离级别下支持



## 行锁

### 介绍

InnoDB实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。

- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。



两种行锁的兼容情况如下：

|             | S（共享锁） | X（排他锁） |
| ----------- | ----------- | ----------- |
| S（共享锁） | 兼容        | 冲突        |
| X（排他锁） | 冲突        | 冲突        |



不同SQL加锁的情况

| SQL                           | 行锁类型   | 说明                                     |
| ----------------------------- | ---------- | ---------------------------------------- |
| INSERT ...                    | 排他锁     | 自动加锁                                 |
| UPDATE ...                    | 排他锁     | 自动加锁                                 |
| DELETE ...                    | 排他锁     | 自动加锁                                 |
| SELECT（正常）                | 不加任何锁 |                                          |
| SELECT ... LOCK IN SHARE MODE | 共享锁     | 需要手动在SELECT之后加LOCK IN SHARE MODE |
| SELECT ... FOR UPDATE         | 排他锁     | 需要手动在SELECT之后加FOR UPDATE         |



### 特点

> 默认情况下，InnoDB在可重复读事务隔离级别运行
>
> InnoDB使用临键锁（行锁+间隙锁）进行搜索和索引扫描，以防止幻读。

- 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。

- InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。





## 间隙锁&临键锁

### 介绍

> 默认情况下，InnoDB在可重复读事务隔离级别运行
>
> InnoDB使用临键锁（行锁+间隙锁）进行搜索和索引扫描，以防止幻读。

- 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。

- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，临键锁退化为间隙锁。

- 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。

>注意：
>
>- 间隙锁唯一目的是防止其他事务插入间隙。
>- 间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。



### 示例：给不存在记录枷锁

- 查看user表数据

```sql
select * from user;

+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | Cpp    |   21 |
|  5 | Java   |   25 |
|  9 | Python |   29 |
+----+--------+------+
```

- 在A事务中执行以下SQL

```sql
begin;
update user set age = 10 where id = 7;
```

- 在任一客户端中执行以下SQL查询

```sql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;

+---------------+-------------+------------+-----------+-----------+-----------+
| object_schema | object_name | index_name | lock_type | lock_mode | lock_data |
+---------------+-------------+------------+-----------+-----------+-----------+
| weibo         | user        | NULL       | TABLE     | IX        | NULL      |
| weibo         | user        | PRIMARY    | RECORD    | X,GAP     | 9         |
+---------------+-------------+------------+-----------+-----------+-----------+
```

>可以发现加了一个行级锁，类型为为排他锁及间隙锁；还加了一个意向排他锁

- 此时在事务B中执行以下SQL

```sql
begin;
insert into user values(6, 'Php', 26);
```

>发现一直阻塞，因为记录5-9的间隙被锁住了（不包括5-9）



### 示例：普通索引等值查询

B+树存索引，都是按顺序从小到大，但是普通索引非唯一，所以需要在查询值的前后查直到不满足条件

- 对user表的age字段建立普通索引

```sql
create index idx_user_age on user(age);
```

- 在事务A中执行以下操作

```sql
begin;
select * from user where age = 10 lock in share mode ;
```

- 在任一客户端中执行以下SQL查询

```sql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;

+---------------+-------------+--------------+-----------+---------------+-----------+
| object_schema | object_name | index_name   | lock_type | lock_mode     | lock_data |
+---------------+-------------+--------------+-----------+---------------+-----------+
| weibo         | user        | NULL         | TABLE     | IS            | NULL      |
| weibo         | user        | idx_user_age | RECORD    | S             | 10, 5     |
| weibo         | user        | PRIMARY      | RECORD    | S,REC_NOT_GAP | 5         |
| weibo         | user        | idx_user_age | RECORD    | S,GAP         | 21, 1     |
+---------------+-------------+--------------+-----------+---------------+-----------+
```

>除了意向共享锁的表锁外：
>
>- 首先有一个针对`PRIMARY`的主键索引加的行级锁，锁住了id为5的行数据
>- 其次有两个针对`idx_user_age`普通索引的行级锁，分别是临键锁和间隙锁
>  - 临键锁：锁住了id=5，age=10的记录本身以及该记录前面的间隙
>  - 间隙锁，锁住了id=1，age=21的记录前面的间隙（合理，第一条id如果不为1这样锁可以防止前面间隙被插入导致的幻读）





### 示例：唯一索引范围查询

- 查看所有行记录

```sql
select * from user;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | Cpp    |   21 |
|  5 | Java   |   10 |
|  6 | Php    |   26 |
|  9 | Python |   29 |
+----+--------+------+
```

- 在事务A中执行以下操作

```sql
begin ;
select * from user where id >= 6 lock in share mode ;
```

- 在任一客户端中执行以下SQL查询

```sql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;

+---------------+-------------+------------+-----------+---------------+------------------------+
| object_schema | object_name | index_name | lock_type | lock_mode     | lock_data              |
+---------------+-------------+------------+-----------+---------------+------------------------+
| weibo         | user        | NULL       | TABLE     | IS            | NULL                   |
| weibo         | user        | PRIMARY    | RECORD    | S,REC_NOT_GAP | 6                      |
| weibo         | user        | PRIMARY    | RECORD    | S             | supremum pseudo-record |
| weibo         | user        | PRIMARY    | RECORD    | S             | 9                      |
+---------------+-------------+------------+-----------+---------------+------------------------+
```

>除了意向共享锁的表锁外，从上往下分别为：
>
>- 针对id=6的记录加了一个行级锁，为普通的行锁
>- 加了一个临键锁，锁住正无穷大（行锁）以及正无穷大到9之间的间隙（间隙锁）
>- 加了一个临键锁，锁住id=9的记录（行锁）以及id=9之前的间隙