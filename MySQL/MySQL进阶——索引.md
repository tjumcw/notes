## MySQL——索引

### 一、存储引擎

主要有三种存储引擎 InnoDB、MyISAM、Memory：

#### 1、InnoDB

##### 1）介绍

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。



##### 2）特点

- DML操作（增删改）遵循ACID，支持事务
- 行级锁，提高并发访问性能
- 支持外键FOREIGN KEY约束，保证数据的完整性和正确性



##### 3）文件

现在仅有一个文件：xxx.ibd

- xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件
- 用于存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。

- 早期版本是ibd + (frm/sdi)



##### 4）逻辑存储结构

![image-20220810125543179](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220810125543179.png)



#### 2、MyISAM

##### 1）介绍

MyISAM是MySQL早期的默认存储引擎。



##### 2）特点

- 不支持事务
- 不支持外键
- 不支持行锁，支持表锁
- 访问速度快



##### 3）文件

- xxx.sdi：存储表结构信息（早期是xxx.frm）
- xxx.MYD: 存储数据
- xxx.MYI: 存储索引



#### 3、Memory

##### 1）介绍

Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。



##### 2）特点

- 内存存放，快
- hash索引（默认）



##### 3）文件

- xxx.sdi：存储表结构信息



#### 4、区别及特点

| 特点     | InnoDB     | MyISAM | Memory |
| -------- | ---------- | ------ | ------ |
| 存储限制 | 64TB       | 有     | 有     |
| 事务     | 支持       | —      | —      |
| 锁       | 行锁和表锁 | 表锁   | 表锁   |
| B+树索引 | 支持       | 支持   | 支持   |
| Hash索引 | —          | —      | 支持   |

>面试题：InnoDB引擎与MyISAM引擎的区别 ?
>
>- InnoDB支持事务，而MyISAM不支持
>- InnoDB支持外键，而MyISAM不支持
>- InnoDB支持行锁和表锁，而MyISAM仅支持表锁不支持行锁
>- InnoDB是聚簇索引，不需要回表（主键作为索引时），MyISAM是非聚簇索引，需要回表
>  - MyISAM通过B+树索引找到需要查的数据的地址，在去数据表中按地址查所需的数据



### 二、索引

#### 1、索引概述

##### 1）介绍

- 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。

- 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据。

- 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。



##### 2）演示

假如我们要执行如下的SQL语句进行查询

```mysql
select * from emp where age = 45;
```

- 在无索引情况下，需要从第一行开始一直扫描到最后一行，称之为全表扫描，性能很差
  - 就算找到了age = 45的数据，还得继续往下找，因为可能有其他age = 45的数据
- 有索引的情况下，如二叉搜索树，就可以极大地减小搜索的时间复杂度



##### 3）索引特点

| 优势                                                         | 劣势                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库 的IO成本                      | 索引列也是要占用空间的。                                     |
| 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。 |

>注意事项：
>
>- 数据库的数据和索引都存在磁盘当中，利用索引减少磁盘访问次数，降低IO成本
>- 通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗（运算）
>- 索引本身也是存在磁盘上的，也得访问磁盘（数据量小不如全表扫描）
>- 进行更新操作时，需要修改索引内部的数据结构，即索引需要额外的维护成本
>  - 增删改需要在对应的数据结构中增加、删除、修改节点，需要维护成本
>  - 但一般而言大部分操作都是读操作



#### 2、索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包括以下几种：

- B+树索引：最常见的索引类型，大部分引擎都支持 B+ 树索引
- Hash索引：底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询
- R树（空间索引）：MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
- 全文索引：是一种通过建立倒排索引,快速匹配文档的方式（通过key找到其所在的文档）



其中，不同引擎对索引结构的支持情况如下：

| 索引        | InnoDB          | MyISAM | Memory |
| ----------- | --------------- | ------ | ------ |
| B+tree索引  | 支持            | 支持   | 支持   |
| Hash 索引   | 不支持          | 不支持 | 支持   |
| R-tree 索引 | 不支持          | 支持   | 不支持 |
| Full-text   | 5.6版本之后支持 | 支持   | 不支持 |



##### 1）二叉树

如果选择二叉树作为索引结构，存在以下缺点

- 主键顺序插入时，会形成一个链表，查询性能大大降低
- 大数据量情况下，层级较深，检索速度慢（磁盘I/O次数也较多）

>如果选择红黑树：
>
>- 如果选择红黑树，红黑树是一颗自平衡二叉树
>- 那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树
>- 即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：
>  - 大数据量情况下，层级较深，检索速度慢



##### ==2）B-Tree==

- B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。
- 最大度数（max-degree）为5(5阶)的B-tree，那这个B树每个节点最多存储4个key，5 个指针

![image-20220810155501957](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220810155501957.png)

>注意：
>
>- 树的度数指的是一个节点的子节点的个数，5个子节点表示夫节点最多有5根指针，即存4个key



特点：

- 5阶的B树，每一个节点最多存储4个key，对应5个指针。
- 每个节点中的key都按照从小到大的顺序排列
- 每个key的左子树中的所有key都小于它，而右子树中的所有key都大于它==（B+树是>=）==。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
  - 原先的数据块按中间元素左右分为两块，向上分裂的中间元素前后的指针分别指向这两块
- 在B树中，非叶子节点和叶子节点都会存放数据。



##### ==3）B+Tree==

- B+Tree是B-Tree的变种，主要区别在于其非叶子节点只存索引不存数据
- 且非叶子节点的索引在叶子节点中均会出现，叶子节点存索引和数据



特点：

- 5阶的B+树，每一个节点最多存储4个key，对应5个指针。
- 内部结点中的key都按照从小到大的顺序排列。
- 对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。
- 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。
  - 原先的数据块按中间元素左右分为两块，向上分裂的中间元素前后的指针分别指向这两块
  - 右块的第一个数据存向上裂变的中间元素，即本身不仅向上裂变，还需要存在右边第一个

- 所有的数据都会出现在叶子节点，叶子节点形成一个单向链表。
  - MySQL优化为双向链表，==便于范围查询和区间访问，利于排序==

- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。



##### 4）Hash

哈希索引就是采用一定的hash算法，将key换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。

特点如下：

- Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
- 无法利用索引完成排序操作
-  查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引



##### ==5）思考题==

>为什么InnoDB存储引擎选择使用B+tree索引结构?
>
>- 相对于二叉树，层级更少，搜索效率高；
>- 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
>  - B树和B+树中每个节点就是==一页，大小固定为16K，存了data的话寸的key就少了==，层数就多了
>  - 层数多了需要访问更多的页，即需要更多次的磁盘IO了
>- 相对Hash索引，B+tree支持范围匹配及排序操作；



#### 3、索引分类

##### 1）索引分类

在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类     | 含义                                                  | 特点                      | 关键字   |
| -------- | ----------------------------------------------------- | ------------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                              | 默认自动创建, 只能 有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                | UNIQUE   |
| 常规索引 | 快速定位特定数据                                      | 可以有多个                |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                | FULLTEXT |

>注意事项：
>
>- 建表时如果指定了主键，会自动创建主键索引
>- 对某个字段加唯一约束时，会自动创建唯一索引
>- 还可以分聚集索引和非聚集索引
>- 还可以分单列索引和联合索引



##### 2）聚集索引&非聚集索引

- 聚集索引：将索引与数据放在一块，叶子节点存放行数据，一个表必须有且仅有一个聚集索引
- 非聚集索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，可以有多个



聚集索引的选取规则如下：

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。



![image-20220810164615538](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220810164615538.png)

>回表查询：
>
>- 先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。



##### 3）思考题

>InnoDB主键索引的B+tree高度为多高呢?
>
>- 已知每个节点是一个页，一页大小为16k
>- 假设一行数据大小为1k，InnoDB的指针占用6个字节，主键为bigint，占用字节数为8
>- 高度为2时，第一行：
>  - n * 8 + (n + 1) * 6 = 16*1024 -> n = 1170，故能存1170个key和1171个指针
>- 第二行能存 1171 * 16 = 18736个数据，因为一共1171个子节点，每个节点能存16个数据
>- 若有第三行，则能存1171 * 1171 * 16 = 21939856个数据，大约2200w



#### 4、索引语法

##### 1）创建索引

```mysql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,...);
```

##### 2）查看索引

```mysql
SHOW INDEX FROM table_name;
```

##### 3）删除索引

```mysql
DROP INDEX index_name ON table_name;
```



#### 5、SQL性能分析

##### 1）SQL执行频率

- 以查询为主的话需要考虑优化

##### 2）慢查询日志

- 记录了所有执行时间超过指定参数的所有 SQL语句的日志。

##### 3）profile详情

- show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了

##### 4）explain

- EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息

>对于一个很大的表：
>
>- 按主键索引查询，很快
>- 对没有建立索引的字段查询，很慢
>- 对没有建立索引的字段建立索引，也很慢（因为需要建立B+树，把全部的数据记录都要存进去）
>- 建立完索引后，对该字段查询，很快



#### 6、索引使用

##### 1）最左前缀法则

- 如果索引了多列（联合索引），要遵守最左前缀法则。
- 最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。
- 如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

>注意事项：
>
>- 最左前缀法则指的是，查询时，最左边的列必须存在，否则索引全部失效
>- 而且中间不能跳过某一列，否则该列后面的字段索引将失效。
>- where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序
>  - 即若建立索引为（a,b,c），select时where顺序为（b,c,a）依旧会索引搜索
>  - select时where若为（c,a），依旧会索引搜索，但只会对a字段索引，因为跳过了b
>- 总结：
>  - 对于(a,b)查询，对(a,b)索引查找
>  - 对于(a,c)查询，只对a索引，因为跳过了b
>  - 对于(a,c,b)查询，会对(a,b,c)进行索引查找
>  - 对于(c,b,a)查询，也会对(a,b,c)进行索引查找
>  - 对于(c,a)查询，只会对a进行索引查找，因为跳过了b
>  - 对于(b,a)查询，会对(a,b)都进行查找
>  - 最左边的字段不能没有，且字段排列顺序无所谓，(c,b,a)也可
>  - 如果丢失了中间的(c,a)，后面索引部分即c失效，因为哪怕优化成了(a,c)也缺失了b



##### 2）范围查询

- 联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。
- 联合索引中，出现范围查询，当范围查询使用>= 或 <= 时，走联合索引

>对于联合索引idx_name_age_job：
>
>- 若是select * from emp where a = 'xx',b > xx,c='xx'，则只有a有效
>- 若是select * from emp where a = 'xx',b >= xx,c='xx'，则(a,b,c)索引都有效



##### 3）索引失效情况

###### 1、索引列运算

==在索引列上进行运算操作， 索引将失效。==

- 进行等值匹配查询时, 索引生效

```mysql
select * from tb_user where phone = '17799990015';
```

- 字段进行函数运算操作之后，索引失效

```mysql
select * from tb_user where substring(phone,10,2) = '15';
```



###### 2、字符串不加引号

==字符串类型字段使用时，不加引号，索引将失效。==

- 对于字符串status字段，加引号，联合索引生效

```mysql
select * from tb_user where profession = '软件工程' and age = 31 and status = '0';
```

- 对于字符串status字段，不加引号，联合索引不生效

```mysql
select * from tb_user where profession = '软件工程' and age = 31 and status = 0;
```

>注意事项：
>
>- 如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。



###### 3、模糊查询

==如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。==

- 尾部模糊匹配，索引不会失效

```mysql
select * from tb_user where profession like '软件%';
```

- 头部模糊匹配，索引失效

```mysql
select * from tb_user where profession like '%工程';
```

>注意事项：
>
>- 在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。



###### 4、or连接条件

==当or连接的条件，左右两侧字段都有索引时，索引才会生效。==

- or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

```mysql
select * from tb_user where id = 10 or age = 23;
```

- 当对age字段建立索引后，再次查询发现会对id和age两个索引进行搜索



###### 5、数据分布影响

==如果MySQL评估使用索引比全表更慢，则不使用索引。==

```mysql
select * from tb_user where phone >= '17799990005';
```

>注意事项：
>
>- 由上SQL，范围查询带等号，能进行索引搜索
>- 但表中所有的phone都大于'17799990005'，最小值本身是'17799990005'
>- 索引搜索和全表搜索的数据量是一样的，MySQL评估后进行全表扫描
>
>就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。



##### 4）SQL提示

在查询的时候，自己来指定使用哪个索引，可以借助于 MySQL的SQL提示来完成

- use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。

```mysql
select * from tb_user use index(idx_user_pro) where profession = '软件工程';
```

- ignore index ： 忽略指定的索引

```mysql
select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';
```

- force index ： 强制使用索引

```mysql
select * from tb_user force index(idx_user_pro) where profession = '软件工程';
```



##### ==5）覆盖索引==

**尽量使用覆盖索引，减少select ***

- 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。



跟踪一组SQL执行的结果进行判断：

- 查id和profession，其中profession和age和status已经建立联合索引

```mysql
explain select id, profession from tb_user where profession = '软件工程' and age = 31 and status = '0' ;
```

>执行原理：
>
>- 查询字段的3个条件已建立联合索引，会按照其进行索引搜索，其中：
>  - 叶子节点分为（profession，age，status）字段的联合索引以及包含的data（即id）
>  - 也就是说一轮查询即可查到待查询的所有字段信息（id，profession），无需回表

- 查id,profession,age, status

```mysql
select id,profession,age, status from tb_user where profession = '软件工程' and age = 31 and status = '0' ;
```

>执行原理：
>
>- 查询条件的三个字段有联合索引，按索引搜索
>- 叶子节点分为（profession，age，status）字段的联合索引以及包含的data（即id）
>- 查询的4个字段能通过一张表（以联合索引建立的表）的查询解决，无需回表

- 查id,profession,age, status, name

```mysql
select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status = '0' ;
```

>执行原理：
>
>- 查询条件的三个字段有联合索引，按索引搜索
>- 叶子节点分为（profession，age，status）字段的联合索引以及包含的data（即id）
>- 但是查询的最后一个字段name不在上述叶子节点的信息中，所以需要通过id主键回表查询

- 查询所有字段

```mysql
select * from tb_user where profession = '软件工程' and age = 31 and status = '0';
```

>注意事项：
>
>- 查询条件的三个字段有联合索引，按索引搜索
>- 叶子节点分为（profession，age，status）字段的联合索引以及包含的data（即id）
>- 由于叶子节点的索引加data也只有（profession，age，status，id）4个字段，故必须通过id回表



所以一般不要使用select *查询：

- 查询返回所有字段值，很容易就会造成回表查询
- 除非是根据主键查询，此时只会扫描聚集索引
- 或者对所有字段建立联合索引



>思考题：
>
>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, 该如何进行才是最优方案:
>
>```mysql
>select id,username,password from tb_user where username = 'itcast';
>```
>
>- 根据分析，id为主键，且查询条件的字段为username，故肯定要对username建立索引
>- 但若仅对username建立索引，其为非聚簇索引，叶子节点存放的data为主键id
>- 那么根据username进行索引搜索时，查到的数据为索引username+数据id，没有password字段，需要回表
>- 故应该针对username以及password建立联合索引，这样不需要回表
>
>```mysql
>create index idx_user_name_pass on tb_user(username, password);
>```



##### 6）前缀索引

- 当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串。
- 这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。
- 此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

###### 1、语法

```mysql
create index idx_xxxx on table_name(column(n));
```

###### 2、前缀长度

- 可以根据索引的选择性来决定
- 而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高。
- 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

```mysql
# 求的是不同email和数据表的记录总数的比值
select count(distinct email) / count(*) from tb_user ;

# 求的是不同email的长度为5的字串和数据表的记录总数的比值
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
```

###### 3、前缀索引的查询流程

![image-20220812165058198](C:\Users\mcw\AppData\Roaming\Typora\typora-user-images\image-20220812165058198.png)

>具体流程：
>
>- 首先根据待查询的字段进行查找，由于对email字段进行了前缀索引，故按前缀搜索
>- 在非聚簇索引表（以email前5个为索引的表）中查到对应的叶子节点，其存放的数据为主键id
>- 根据id回表去主键索引的表中查询对应id的数据行，并比对其email是否为待查条件
>  - 仅仅前缀5位不能确定其就是所查的条件，故得比较
>- 查到该条后继续在非聚簇索引表中向后查下一个叶子节点，直到其不满足前缀条件
>  - 因为B+树按照索引进行了排序，可能有多个数据的索引字段相同
>  - 叶子节点也是按索引从左往右排序，故还得往右找直到找到不满足查询条件为止
>  - 对每个满足的依旧对id回表查，并比对完整email是否等于查询条件



##### 7）单列索引与联合索引

单列索引：即一个索引只包含单个列。 

联合索引：即一个索引包含了多个列。



1、执行一条SQL语句，查询条件为phone和name字段，其中各自建立了单列索引

- 在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引。
- 也就是说，只能走一个字段的索引，此时是会回表查询的。



2、创建一个phone和name字段的联合索引后依旧查询

- 查询时，就走了联合索引，而在联合索引中包含 phone、name的信息。
- 在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的。

>注意事项：
>
>- 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。



#### 7、索引设计原则

##### 1）表级

- 针对数据量较大，且查询比较频繁的表建立索引。

##### 2）字段级

- 针对常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
- 尽量选择区分度高的字段建立索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

##### 3）索引级

- 如果是字符串类型的字段，字段较长时可建立前缀索引。
- 尽量使用联合索引，减少单列索引，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。

- 索引不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改查的效率。

- 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。